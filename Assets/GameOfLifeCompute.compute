RWStructuredBuffer<uint> gridOut;
StructuredBuffer<uint> gridIn;
uint rng_state;
uint width;
uint height;

#pragma kernel Update // ID 0
[numthreads(8, 8, 1)]
void Update(uint3 id : SV_DispatchThreadID) {
  // Leave 1 pixel border
  if (id.x == 0 || id.x >= width - 1 || id.y == 0 || id.y >= height - 1) {
    return;
  }

  uint index = id.y * width + id.x;

  uint neighbours = 0;
  neighbours += gridIn[index - width - 1]; // Top left
  neighbours += gridIn[index - width]; // Top
  neighbours += gridIn[index - width + 1]; // Top Right

  neighbours += gridIn[index - 1]; // Left
  neighbours += gridIn[index + 1]; // Right

  neighbours += gridIn[index + width - 1]; // Bottom left
  neighbours += gridIn[index + width]; // Bottom
  neighbours += gridIn[index + width + 1]; // Bottom Right

  bool alive = gridIn[index] > 0;
  if ((alive && neighbours == 2) || neighbours == 3) {
    gridOut[index] = 1;
  } else {
    gridOut[index] = 0;
  }
}

float pcg_hash(uint input) {
  uint state = input * 747796405u + 2891336453u;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  return ((word >> 22u) ^ word) / 4294967295.0;
}

#pragma kernel Generate // ID 1
[numthreads(8, 8, 1)]
void Generate(uint3 id : SV_DispatchThreadID) {
  // Leave 1 pixel border
  if (id.x == 0 || id.x >= width - 1 || id.y == 0 || id.y >= height - 1) {
    return;
  }

  int index = id.y * width + id.x;
  uint alive = round(pcg_hash(rng_state + index));
  gridOut[index] = alive;
}

#pragma kernel Clear // ID 2
[numthreads(8, 8, 1)]
void Clear(uint3 id : SV_DispatchThreadID) {
  int index = id.y * width + id.x;
  gridOut[index] = 0;
}

uint mouseIndex;
#pragma kernel Draw // ID 3
[numthreads(1, 1, 1)]
void Draw(uint3 id : SV_DispatchThreadID) {
  gridOut[mouseIndex] = 1;
}