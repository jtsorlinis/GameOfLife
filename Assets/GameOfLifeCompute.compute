RWStructuredBuffer<uint> Result;
StructuredBuffer<uint> Input;
uint rng_state;
uint width;
uint height;

#pragma kernel Update // ID 0
[numthreads(8, 8, 1)]
void Update(uint3 id : SV_DispatchThreadID) {
  // Leave 1 pixel border
  if (id.x == 0 || id.x >= width - 1 || id.y == 0 || id.y >= height - 1) {
    return;
  }

  uint index = id.y * width + id.x;

  uint neighbours = 0;
  neighbours += Input[index - width - 1]; // Top left
  neighbours += Input[index - width]; // Top
  neighbours += Input[index - width + 1]; // Top Right

  neighbours += Input[index - 1]; // Left
  neighbours += Input[index + 1]; // Right

  neighbours += Input[index + width - 1]; // Bottom left
  neighbours += Input[index + width]; // Bottom
  neighbours += Input[index + width + 1]; // Bottom Right

  uint self = Input[index] > 0;
  if ((self > 0 && neighbours == 2) || neighbours == 3) {
    Result[index] = 1;
  } else {
    Result[index] = 0;
  }
}

float pcg_hash(uint input) {
  uint state = input * 747796405u + 2891336453u;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  return ((word >> 22u) ^ word) / 4294967295.0;
}

#pragma kernel Generate // ID 1
[numthreads(8, 8, 1)]
void Generate(uint3 id : SV_DispatchThreadID) {
  // Leave 1 pixel border
  if (id.x == 0 || id.x >= width - 1 || id.y == 0 || id.y >= height - 1) {
    return;
  }

  int index = id.y * width + id.x;
  
  uint alive = round(pcg_hash(rng_state + index));
  Result[index] = alive;
}



